#!/bin/bash
# Link Health Capability - Scans for broken links

# Don't exit on error - let the router handle error tracking
set +e

# Load shared utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../../shared/utils.sh"
source "$SCRIPT_DIR/../../shared/config.sh"

CAPABILITY_NAME="Link-Health"
LOG_FILE="link-health-$(date +%Y%m%d-%H%M%S).log"

log_info "Starting $CAPABILITY_NAME capability..."

# Function to scan for broken links
scan_links() {
    log_info "Scanning for broken links..."
    
    # Ensure linkinator is installed
    ensure_dependency "linkinator" "npm install -g linkinator"
    
    # Build skip domains string
    local skip_args=""
    for domain in "${LINK_HEALTH_SKIP_DOMAINS[@]}"; do
        skip_args="$skip_args --skip $domain"
    done
    
    # Run linkinator scan
    linkinator . \
        --recurse \
        $skip_args \
        --format json \
        --markdown \
        --html \
        > link-scan-results.json 2>&1 || true
    
    # Parse results
    if [ -f link-scan-results.json ]; then
        ensure_dependency "jq" "sudo apt-get update && sudo apt-get install -y jq"
        
        local broken_count=$(cat link-scan-results.json | jq '[.[] | select(.status >= 400)] | length' 2>/dev/null || echo "0")
        local total_count=$(cat link-scan-results.json | jq 'length' 2>/dev/null || echo "0")
        
        broken_count=${broken_count:-0}
        total_count=${total_count:-0}
        
        local output_file="${GITHUB_OUTPUT:-/tmp/agent_outputs.txt}"
        echo "broken_count=$broken_count" >> "$output_file"
        echo "total_count=$total_count" >> "$output_file"
        
        # Extract broken links
        cat link-scan-results.json | jq -r '[.[] | select(.status >= 400)] | .[] | "\(.url) - \(.status) - \(.parent)"' > broken-links.txt 2>/dev/null || true
        touch broken-links.txt
        
        log_info "Scan complete: $broken_count broken links out of $total_count total"
    else
        log_warning "No scan results file generated"
        local output_file="${GITHUB_OUTPUT:-/tmp/agent_outputs.txt}"
        echo "broken_count=0" >> "$output_file"
        echo "total_count=0" >> "$output_file"
        touch broken-links.txt
    fi
}

# Function to analyze broken links
analyze_links() {
    local output_file="${GITHUB_OUTPUT:-/tmp/agent_outputs.txt}"
    
    if [ ! -f broken-links.txt ] || [ ! -s broken-links.txt ]; then
        log_info "No broken links found"
        echo "broken_links=" >> "$output_file"
        echo "has_broken=false" >> "$output_file"
        echo "internal_broken=0" >> "$output_file"
        echo "external_broken=0" >> "$output_file"
        return 0
    fi
    
    local broken_links=$(cat broken-links.txt || echo "")
    
    # Set multiline output
    {
        echo "broken_links<<EOF"
        echo "$broken_links"
        echo "EOF"
    } >> "$output_file"
    
    # Categorize broken links
    if [ -n "$broken_links" ]; then
        local internal=$(echo "$broken_links" | grep -c "elamcb.github.io\|github.com/ElaMCB" 2>/dev/null || echo "0")
        local external=$(echo "$broken_links" | grep -v "elamcb.github.io\|github.com/ElaMCB" | grep -v "^$" | wc -l 2>/dev/null | tr -d ' ' || echo "0")
    else
        local internal="0"
        local external="0"
    fi
    
    internal=${internal:-0}
    external=${external:-0}
    
    echo "internal_broken=$internal" >> "$output_file"
    echo "external_broken=$external" >> "$output_file"
    echo "has_broken=true" >> "$output_file"
    
    log_info "Analysis complete: $internal internal, $external external broken links"
}

# Function to create fix PR
create_fix_pr() {
    local broken_count="$1"
    local total_count="$2"
    local internal="$3"
    local external="$4"
    local broken_links="$5"
    
    local branch_name="lha/fix-broken-links-$(date +%Y%m%d)"
    setup_git
    git checkout -b "$branch_name"
    
    # Create fix report
    cat > docs/link-health-report.md <<EOF
# Link Health Report - $(date +%Y-%m-%d)

## Summary
- **Total Links Scanned**: $total_count
- **Broken Links Found**: $broken_count
- **Internal Broken**: $internal
- **External Broken**: $external

## Broken Links

\`\`\`
$broken_links
\`\`\`

## Next Steps

This report was generated by $AGENT_NAME - $CAPABILITY_NAME capability. Please review and fix the broken links listed above.

---
*Generated by $AGENT_NAME - $CAPABILITY_NAME capability*
EOF
    
    git add docs/link-health-report.md
    git commit -m "Link health report - $broken_count broken links found" || exit 0
    
    local pr_body="## Link Health Report

**Broken Links**: $broken_count / $total_count
- Internal: $internal
- External: $external

## Broken Links Detected

\`\`\`
$broken_links
\`\`\`

## Action Required

Please review the broken links and fix them. The report has been saved to \`docs/link-health-report.md\`.

---
*Generated by $AGENT_NAME - $CAPABILITY_NAME capability*"
    
    create_github_pr "Fix broken links ($broken_count found)" "$pr_body" "$branch_name" "link-health,automated"
    log_info "Created PR for broken links fix"
}

# Function to create critical issue for internal broken links
create_critical_issue() {
    local internal="$1"
    local external="$2"
    local total="$3"
    local broken_links="$4"
    
    local title="Critical - $internal internal broken links detected"
    local body="## Critical Link Health Issue

**Internal Broken Links**: $internal
**External Broken Links**: $external
**Total Broken**: $total

## Broken Links

\`\`\`
$broken_links
\`\`\`

## Priority

Internal broken links should be fixed immediately as they affect user experience on the portfolio site.

---
*Generated by $AGENT_NAME - $CAPABILITY_NAME capability*"
    
    create_github_issue "$title" "$body" "link-health,critical,automated"
    log_info "Created critical issue for internal broken links"
}

# Function to check for missing data files referenced in HTML/JS
check_data_files() {
    log_info "Checking for missing data files referenced in pages..."
    
    local missing_files=""
    local issues_found=0
    
    # Find all HTML files
    while IFS= read -r html_file; do
        # Extract fetch() calls that reference local files
        local fetch_calls=$(grep -oE "fetch\(['\"]([^'\"]+)['\"]\)" "$html_file" 2>/dev/null || true)
        
        if [ -n "$fetch_calls" ]; then
            echo "$fetch_calls" | while IFS= read -r fetch_call; do
                # Extract the file path from fetch('path') or fetch("path")
                local file_path=$(echo "$fetch_call" | sed -E "s/.*fetch\(['\"]([^'\"]+)['\"]\).*/\1/" | grep -v "^http" | grep -v "^//" || true)
                
                if [ -n "$file_path" ]; then
                    # Resolve relative paths
                    local html_dir=$(dirname "$html_file")
                    local resolved_path=""
                    
                    if [[ "$file_path" == ./* ]] || [[ "$file_path" == ../* ]]; then
                        resolved_path=$(cd "$html_dir" && realpath "$file_path" 2>/dev/null || echo "")
                    else
                        # Try relative to HTML file directory
                        resolved_path="$html_dir/$file_path"
                    fi
                    
                    # Check if file exists
                    if [ -n "$resolved_path" ] && [ ! -f "$resolved_path" ]; then
                        missing_files="${missing_files}${html_file}: Missing data file '$file_path' (resolved: $resolved_path)\n"
                        issues_found=$((issues_found + 1))
                    fi
                fi
            done
        fi
    done < <(find . -name "*.html" -type f ! -path "./node_modules/*" ! -path "./.git/*")
    
    if [ "$issues_found" -gt 0 ]; then
        log_warning "Found $issues_found missing data file references"
        echo -e "$missing_files" >> missing-data-files.txt
        local output_file="${GITHUB_OUTPUT:-/tmp/agent_outputs.txt}"
        echo "missing_data_files=$issues_found" >> "$output_file"
        echo "has_missing_data=true" >> "$output_file"
    else
        log_info "All referenced data files exist"
        local output_file="${GITHUB_OUTPUT:-/tmp/agent_outputs.txt}"
        echo "missing_data_files=0" >> "$output_file"
        echo "has_missing_data=false" >> "$output_file"
        touch missing-data-files.txt
    fi
}

# Main execution
main() {
    scan_links
    
    local output_file="${GITHUB_OUTPUT:-/tmp/agent_outputs.txt}"
    local broken_count=$(grep '^broken_count=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "0")
    local total_count=$(grep '^total_count=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "0")
    
    analyze_links
    
    # Check for missing data files
    check_data_files
    
    local has_broken=$(grep '^has_broken=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "false")
    local has_missing_data=$(grep '^has_missing_data=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "false")
    local missing_data_count=$(grep '^missing_data_files=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "0")
    local internal=$(grep '^internal_broken=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "0")
    local external=$(grep '^external_broken=' "$output_file" 2>/dev/null | cut -d'=' -f2 || echo "0")
    local broken_links=$(cat broken-links.txt 2>/dev/null || echo "")
    local missing_files=$(cat missing-data-files.txt 2>/dev/null || echo "")
    
    # Create issue for missing data files
    if [ "$has_missing_data" = "true" ] && [ "$missing_data_count" -gt 0 ]; then
        local title="Missing Data Files - Pages May Not Display Content"
        local body="## Missing Data Files Detected

**Count**: $missing_data_count

## Details

\`\`\`
$missing_files
\`\`\`

## Impact

Pages that reference these missing files may:
- Show \"Loading...\" indefinitely
- Display empty states when they should have content
- Fail to load data via JavaScript fetch() calls

## Action Required

Please verify these files exist or fix the JavaScript paths.

---
*Generated by $AGENT_NAME - $CAPABILITY_NAME capability*"
        
        create_github_issue "$title" "$body" "link-health,data-files,automated"
        log_warning "Created issue for missing data files"
    fi
    
    if [ "$has_broken" = "true" ]; then
        create_fix_pr "$broken_count" "$total_count" "$internal" "$external" "$broken_links"
        
        if [ "$internal" -gt "0" ]; then
            create_critical_issue "$internal" "$external" "$broken_count" "$broken_links"
        fi
    else
        log_success "All links are healthy! ($total_count links scanned)"
    fi
    
    log_success "$CAPABILITY_NAME capability completed"
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi

