name: Unified Autonomous Agent

on:
  # CI Fix triggers
  workflow_run:
    workflows: ["CI", "Tests", "Build"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      capability:
        description: 'Capability to run (ci-fix, link-health, security, all)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - ci-fix
          - link-health
          - security
  # Link Health triggers
  schedule:
    # Run every Monday at 9 AM UTC
    - cron: '0 9 * * 1'
  push:
    paths:
      - '**.html'
      - '**.md'
      - 'index.html'
      - 'package.json'
      - 'package-lock.json'
      - '**/*.js'
      - '**/*.py'

jobs:
  unified-agent:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      security-events: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Make scripts executable
        run: |
          chmod +x agents/router.sh
          chmod +x agents/capabilities/*/*.sh
          chmod +x agents/shared/*.sh

      - name: Determine capability to run
        id: determine-capability
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            if [ "${{ github.event.workflow_run.conclusion }}" == "failure" ]; then
              echo "capability=ci-fix" >> $GITHUB_OUTPUT
              echo "workflow_event=workflow_run" >> $GITHUB_OUTPUT
            else
              echo "capability=skip" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "capability=${{ github.event.inputs.capability }}" >> $GITHUB_OUTPUT
            echo "workflow_event=workflow_dispatch" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "schedule" ]; then
            echo "capability=all" >> $GITHUB_OUTPUT
            echo "workflow_event=schedule" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "push" ]; then
            # Check which files changed (handle empty/modified gracefully)
            MODIFIED_FILES="${{ github.event.head_commit.modified }}"
            if [ -z "$MODIFIED_FILES" ]; then
              # If modified is empty, try to get from git diff
              MODIFIED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
            if echo "$MODIFIED_FILES" | grep -qE "(\.html|\.md|index\.html)"; then
              echo "capability=link-health" >> $GITHUB_OUTPUT
            elif echo "$MODIFIED_FILES" | grep -qE "(package\.json|package-lock\.json|\.js|\.py)"; then
              echo "capability=security" >> $GITHUB_OUTPUT
            else
              echo "capability=all" >> $GITHUB_OUTPUT
            fi
            echo "workflow_event=push" >> $GITHUB_OUTPUT
          else
            echo "capability=all" >> $GITHUB_OUTPUT
            echo "workflow_event=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Get failed workflow logs (for CI-Fix)
        if: steps.determine-capability.outputs.capability == 'ci-fix'
        id: get-logs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            RUN_ID="${{ github.event.workflow_run.id }}"
            WORKFLOW_NAME="${{ github.event.workflow_run.name }}"
            
            echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
            echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
            
            echo "Downloading logs for workflow: $WORKFLOW_NAME"
            # Use GitHub API with curl (no GitHub CLI needed)
            curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/logs" \
              -L -o workflow_logs.txt 2>&1 || true
            
            if [ ! -s workflow_logs.txt ]; then
              echo "Warning: workflow_logs.txt is empty or doesn't exist"
            else
              echo "Logs downloaded successfully ($(wc -l < workflow_logs.txt) lines)"
            fi
          else
            echo "Manual trigger - skipping log download (no failed workflow to analyze)"
            touch workflow_logs.txt
          fi

      - name: Initialize UAA Status File
        if: steps.determine-capability.outputs.capability != 'skip'
        run: |
          mkdir -p docs
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          # Initialize status file if it doesn't exist
          if [ ! -f "docs/uaa-status.json" ]; then
            cat > docs/uaa-status.json << EOF
          {
            "last_updated": "$TIMESTAMP",
            "workflow_status": "running",
            "capabilities": {
              "ci-fix": {
                "status": "unknown",
                "last_run": "N/A",
                "last_success": "N/A",
                "last_failure": "N/A",
                "total_runs": 0,
                "success_count": 0,
                "failure_count": 0
              },
              "link-health": {
                "status": "unknown",
                "last_run": "N/A",
                "last_success": "N/A",
                "last_failure": "N/A",
                "total_runs": 0,
                "success_count": 0,
                "failure_count": 0
              },
              "security": {
                "status": "unknown",
                "last_run": "N/A",
                "last_success": "N/A",
                "last_failure": "N/A",
                "total_runs": 0,
                "success_count": 0,
                "failure_count": 0
              }
            },
            "recent_activity": []
          }
          EOF
          else
            # Update workflow status to running if file exists
            if command -v jq >/dev/null 2>&1; then
              jq ".workflow_status = \"running\" | .last_updated = \"$TIMESTAMP\"" docs/uaa-status.json > docs/uaa-status.json.tmp && mv docs/uaa-status.json.tmp docs/uaa-status.json || true
            fi
          fi

      - name: Run Unified Agent (UAA)
        if: steps.determine-capability.outputs.capability != 'skip'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_WORKFLOW: ${{ github.workflow }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: |
          # Debug: Show current directory and verify script exists
          echo "Current directory: $(pwd)"
          echo "Checking if router.sh exists:"
          ls -la agents/router.sh || echo "ERROR: router.sh not found!"
          echo "Checking if shared/utils.sh exists:"
          ls -la agents/shared/utils.sh || echo "ERROR: utils.sh not found!"
          echo "Checking if shared/config.sh exists:"
          ls -la agents/shared/config.sh || echo "ERROR: config.sh not found!"
          echo "Capability: ${{ steps.determine-capability.outputs.capability }}"
          echo "Workflow event: ${{ steps.determine-capability.outputs.workflow_event }}"
          
          # Test sourcing utils.sh
          echo "Testing utils.sh source..."
          bash -c "source agents/shared/utils.sh && echo 'utils.sh sourced successfully'" || echo "ERROR: Failed to source utils.sh"
          
          # Run the router with explicit error handling and verbose output
          echo "Running router.sh..."
          bash -x agents/router.sh "${{ steps.determine-capability.outputs.capability }}" "${{ steps.determine-capability.outputs.workflow_event }}" 2>&1 || {
            EXIT_CODE=$?
            echo "ERROR: Router failed with exit code $EXIT_CODE"
            # Update status even on failure
            bash agents/shared/update_status.sh "ci-fix" "failure" "UAA router failed with exit code $EXIT_CODE" || true
            exit $EXIT_CODE
          }

      - name: Update UAA Status and Dashboard
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          # Install jq if needed
          sudo apt-get update && sudo apt-get install -y jq || true
          
          # Ensure status file exists
          mkdir -p docs
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          if [ ! -f "docs/uaa-status.json" ]; then
            cat > docs/uaa-status.json << EOF
          {
            "last_updated": "$TIMESTAMP",
            "workflow_status": "${{ job.status }}",
            "capabilities": {
              "ci-fix": {"status": "unknown", "last_run": "N/A", "last_success": "N/A", "last_failure": "N/A", "total_runs": 0, "success_count": 0, "failure_count": 0},
              "link-health": {"status": "unknown", "last_run": "N/A", "last_success": "N/A", "last_failure": "N/A", "total_runs": 0, "success_count": 0, "failure_count": 0},
              "security": {"status": "unknown", "last_run": "N/A", "last_success": "N/A", "last_failure": "N/A", "total_runs": 0, "success_count": 0, "failure_count": 0}
            },
            "recent_activity": []
          }
          EOF
          fi
          
          # Update workflow status - ensure we update it even if capabilities didn't run
          if command -v jq >/dev/null 2>&1; then
            if [ -f "docs/uaa-status.json" ]; then
              jq ".workflow_status = \"${{ job.status }}\" | .last_updated = \"$TIMESTAMP\"" docs/uaa-status.json > docs/uaa-status.json.tmp && mv docs/uaa-status.json.tmp docs/uaa-status.json || true
              echo "Updated workflow_status to: ${{ job.status }}"
            else
              echo "WARNING: Status file not found after workflow execution"
            fi
          else
            echo "WARNING: jq not available, cannot update workflow status"
          fi
          
          # Make status scripts executable
          chmod +x agents/shared/update_status.sh
          chmod +x agents/shared/generate_status_dashboard.sh
          
          # Generate status dashboard
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          bash agents/shared/generate_status_dashboard.sh > /tmp/uaa-dashboard.md || {
            # Fallback if dashboard generation fails
            WORKFLOW_STATUS="${{ job.status }}"
            case "$WORKFLOW_STATUS" in
              success) STATUS_BADGE="ðŸŸ¢ Success" ;;
              failure) STATUS_BADGE="ðŸ”´ Failed" ;;
              cancelled) STATUS_BADGE="âšª Cancelled" ;;
              *) STATUS_BADGE="âšª Unknown" ;;
            esac
            cat > /tmp/uaa-dashboard.md << EOF
          ## UAA Status Dashboard

          **Last Updated:** $TIMESTAMP

          | Component | Status | Last Run | Details |
          |-----------|--------|----------|---------|
          | **UAA Workflow** | $STATUS_BADGE | $TIMESTAMP | [View Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          | **CI-Fix Capability** | âšª Unknown | N/A | [View Status](./docs/uaa-status.json) |
          | **Link-Health Capability** | âšª Unknown | N/A | [View Status](./docs/uaa-status.json) |
          | **Security Capability** | âšª Unknown | N/A | [View Status](./docs/uaa-status.json) |

          ### Quick Links
          - [UAA Success Indicators Guide](./docs/UAA_SUCCESS_INDICATORS.md)
          - [UAA Architecture](./docs/UNIFIED_AGENT_ARCHITECTURE.html)
          - [Agent README](./agents/README.md)
          - [View All Workflow Runs](https://github.com/${{ github.repository }}/actions/workflows/unified-autonomous-agent.yml)

          ---
          *Dashboard auto-updated by UAA after each run*
          EOF
          }
          
          # Update README with dashboard
          python3 << 'PYTHON_SCRIPT'
          import re
          import sys
          
          try:
              with open('README.md', 'r', encoding='utf-8') as f:
                  readme = f.read()
              
              # Read dashboard content
              with open('/tmp/uaa-dashboard.md', 'r', encoding='utf-8') as f:
                  dashboard = f.read()
              
              # Find and replace dashboard section - use a more flexible pattern
              # Match from "## UAA Status Dashboard" to the end marker
              pattern = r'(## UAA Status Dashboard.*?---\s*\*Dashboard auto-updated.*?\*)'
              
              if re.search(pattern, readme, re.DOTALL | re.MULTILINE):
                  readme = re.sub(pattern, dashboard, readme, flags=re.DOTALL | re.MULTILINE)
                  print("Found existing dashboard section and replaced it")
              else:
                  # Try to find the section more flexibly
                  # Look for "## UAA Status Dashboard" anywhere
                  dashboard_start = readme.find('## UAA Status Dashboard')
                  if dashboard_start != -1:
                      # Find the next section (##) or end of file
                      next_section = readme.find('\n## ', dashboard_start + 1)
                      if next_section == -1:
                          next_section = len(readme)
                      else:
                          # Go back to find the end of previous line
                          next_section = readme.rfind('\n', dashboard_start, next_section)
                          if next_section == -1:
                              next_section = len(readme)
                      
                      # Replace the section
                      readme = readme[:dashboard_start] + dashboard + readme[next_section:]
                      print("Found dashboard section marker and replaced content")
                  else:
                      # Insert after "## Autonomous Agents Ecosystem" section
                      insert_pos = readme.find('## Autonomous Agents Ecosystem')
                      if insert_pos != -1:
                          # Find end of that section (next ## or end of file)
                          next_section = readme.find('\n## ', insert_pos + 1)
                          if next_section == -1:
                              next_section = len(readme)
                          else:
                              # Find the newline before the next section
                              next_section = readme.rfind('\n', insert_pos, next_section)
                              if next_section == -1:
                                  next_section = len(readme)
                          
                          readme = readme[:next_section] + '\n\n' + dashboard + '\n\n' + readme[next_section:]
                          print("Inserted dashboard after Autonomous Agents Ecosystem section")
                      else:
                          print("ERROR: Could not find insertion point in README", file=sys.stderr)
                          sys.exit(1)
              
              with open('README.md', 'w', encoding='utf-8') as f:
                  f.write(readme)
              
              print("README dashboard updated successfully")
          except Exception as e:
              print(f"ERROR updating README: {e}", file=sys.stderr)
              sys.exit(1)
          PYTHON_SCRIPT
          
          # Verify the update worked
          if grep -q "UAA Status Dashboard" README.md 2>/dev/null; then
              echo "âœ“ README dashboard section found after update"
          else
              echo "âš  WARNING: Dashboard section not found in README after update"
          fi
          
          # Commit and push dashboard update
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add files
          git add README.md docs/uaa-status.json docs/uaa-diagnostics.json 2>/dev/null || true
          
          # Check if there are any changes to commit
          if git diff --staged --quiet 2>/dev/null; then
            echo "No changes to commit for dashboard update"
            # Debug: Show status of files
            echo "Current status:"
            git status --short docs/uaa-status.json README.md docs/uaa-diagnostics.json 2>/dev/null || true
          else
            echo "Changes detected, committing..."
            # Show what we're committing for debugging
            echo "Files to commit:"
            git status --short docs/uaa-status.json README.md docs/uaa-diagnostics.json 2>/dev/null || true
            
            git commit -m "UAA: Update status dashboard [skip ci]" || {
              echo "WARNING: Failed to commit dashboard update"
              # Try to see why commit failed
              git status
              exit 0  # Don't fail the workflow
            }
            
            # Push the changes
            git push origin HEAD:${{ github.ref_name }} || {
              echo "WARNING: Failed to push dashboard update"
              exit 0  # Don't fail the workflow
            }
            
            echo "âœ“ Dashboard update committed and pushed successfully"
          fi

      - name: UAA execution summary
        if: always()
        run: |
          echo "========================================="
          echo "UAA (Unified Autonomous Agent) - Execution Summary"
          echo "========================================="
          echo "Capability: ${{ steps.determine-capability.outputs.capability }}"
          echo "Workflow Event: ${{ steps.determine-capability.outputs.workflow_event }}"
          echo "Status: ${{ job.status }}"
          if [ "${{ job.status }}" == "failure" ]; then
            echo ""
            echo "[WARNING] UAA encountered an error. Diagnostic information:"
            if [ -f "docs/uaa-diagnostics.json" ]; then
              echo "View diagnostics: docs/uaa-diagnostics.json"
              cat docs/uaa-diagnostics.json | jq '.' 2>/dev/null || cat docs/uaa-diagnostics.json
            fi
          fi
          echo "========================================="

